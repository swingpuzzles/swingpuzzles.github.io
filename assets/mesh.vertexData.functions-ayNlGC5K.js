function l(o){return Math.floor(o/8)}function y(o){return 1<<o%8}class x{constructor(e){this.size=e,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(e){if(e>=this.size)throw new RangeError("Bit index out of range");const n=l(e),r=y(e);return(this._byteArray[n]&r)!==0}set(e,n){if(e>=this.size)throw new RangeError("Bit index out of range");const r=l(e),s=y(e);n?this._byteArray[r]|=s:this._byteArray[r]&=~s}}function w(o){const e=[],n=o.length/3;for(let t=0;t<n;t++)e.push([o[t*3],o[t*3+1],o[t*3+2]]);const r=new Map;for(let t=0;t<e.length;t++){const a=e[t];for(const c of a){let f=r.get(c);f||r.set(c,f=[]),f.push(t)}}const s=new x(n),h=[],p=t=>{const a=[t];for(;a.length>0;){const c=a.pop();if(!s.get(c)){s.set(c,!0),h.push(e[c]);for(const f of e[c]){const u=r.get(f);if(!u)return;for(const g of u)s.get(g)||a.push(g)}}}};for(let t=0;t<n;t++)s.get(t)||p(t);let i=0;for(const t of h)o[i++]=t[0],o[i++]=t[1],o[i++]=t[2]}export{w as OptimizeIndices};
