import{P as U,j as P,k as T,g as k,l as z,B as x,m as _,n as M,H as F,W as N,A as W,I as g,o as L,p as B,q as G,C as m,b as O,E,r as S,s as Z,t as Y,u as I,v as H,w as X,x as j}from"./index-BVncc99J.js";const V=20000630;function q(n,l){if(n.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const s=n.getUint8(4),r=n.getUint8(5),e={singleTile:!!(r&2),longName:!!(r&4),deepFormat:!!(r&8),multiPart:!!(r&16)};l.value=8;const i={};let t=!0;for(;t;){const a=U(n.buffer,l);if(!a)t=!1;else{const c=U(n.buffer,l),o=P(n,l),u=T(n,l,c,o);u===void 0?k.Warn(`Unknown header attribute type ${c}'.`):i[a]=u}}if((r&-5)!=0)throw new Error("Unsupported file format");return{version:s,spec:e,...i}}function $(n){let l=n.byteLength;const s=[];let r=0;const e=new DataView(n);for(;l>0;){const i=e.getInt8(r++);if(i<0){const t=-i;l-=t+1;for(let a=0;a<t;a++)s.push(e.getUint8(r++))}else{const t=i;l-=2;const a=e.getUint8(r++);for(let c=0;c<t+1;c++)s.push(a)}}return s}function v(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function J(n){const l=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),s=new Uint8Array($(l)),r=new Uint8Array(s.length);return L(s),B(s,r),new DataView(r.buffer)}function R(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),s=fflate.unzlibSync(l),r=new Uint8Array(s.length);return L(s),B(s,r),new DataView(r.buffer)}function K(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),s=fflate.unzlibSync(l),r=n.lines*n.channels*n.width,e=n.type==1?new Uint16Array(r):new Uint32Array(r);let i=0,t=0;const a=new Array(4);for(let c=0;c<n.lines;c++)for(let o=0;o<n.channels;o++){let u=0;switch(n.type){case 1:a[0]=i,a[1]=a[0]+n.width,i=a[1]+n.width;for(let h=0;h<n.width;++h){const w=s[a[0]++]<<8|s[a[1]++];u+=w,e[t]=u,t++}break;case 2:a[0]=i,a[1]=a[0]+n.width,a[2]=a[1]+n.width,i=a[2]+n.width;for(let h=0;h<n.width;++h){const w=s[a[0]++]<<24|s[a[1]++]<<16|s[a[2]++]<<8;u+=w,e[t]=u,t++}break}}return new DataView(e.buffer)}function Q(n){const l=n.viewer,s={value:n.offset.value},r=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),e=new Uint8Array(x);let i=0;const t=new Array(n.channels);for(let f=0;f<n.channels;f++)t[f]={},t[f].start=i,t[f].end=t[f].start,t[f].nx=n.width,t[f].ny=n.lines,t[f].size=n.type,i+=t[f].nx*t[f].ny*t[f].size;const a=z(l,s),c=z(l,s);if(c>=x)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=c)for(let f=0;f<c-a+1;f++)e[f+a]=_(l,s);const o=new Uint16Array(G),u=M(e,o),h=P(l,s);F(n.array,l,s,h,r,i);for(let f=0;f<n.channels;++f){const p=t[f];for(let y=0;y<t[f].size;++y)N(r,p.start+y,p.nx,p.size,p.ny,p.nx*p.size,u)}W(o,r,i);let w=0;const C=new Uint8Array(r.buffer.byteLength);for(let f=0;f<n.lines;f++)for(let p=0;p<n.channels;p++){const y=t[p],b=y.nx*y.size,A=new Uint8Array(r.buffer,y.end*g,b*g);C.set(A,w),w+=b*g,y.end+=b}return new DataView(C.buffer)}async function d(n,l,s,r){const e={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:s,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case m.NO_COMPRESSION:e.lines=1,e.uncompress=v;break;case m.RLE_COMPRESSION:e.lines=1,e.uncompress=J;break;case m.ZIPS_COMPRESSION:e.lines=1,e.uncompress=R,await O.LoadScriptAsync(E.FFLATEUrl);break;case m.ZIP_COMPRESSION:e.lines=16,e.uncompress=R,await O.LoadScriptAsync(E.FFLATEUrl);break;case m.PIZ_COMPRESSION:e.lines=32,e.uncompress=Q;break;case m.PXR24_COMPRESSION:e.lines=16,e.uncompress=K,await O.LoadScriptAsync(E.FFLATEUrl);break;default:throw new Error(m[n.compression]+" is unsupported")}e.scanlineBlockSize=e.lines;const i={};for(const o of n.channels)switch(o.name){case"R":case"G":case"B":case"A":i[o.name]=!0,e.type=o.pixelType;break;case"Y":i[o.name]=!0,e.type=o.pixelType;break}let t=!1;if(i.R&&i.G&&i.B&&i.A)e.outputChannels=4,e.decodeChannels={R:0,G:1,B:2,A:3};else if(i.R&&i.G&&i.B)t=!0,e.outputChannels=4,e.decodeChannels={R:0,G:1,B:2,A:3};else if(i.R&&i.G)e.outputChannels=2,e.decodeChannels={R:0,G:1};else if(i.R)e.outputChannels=1,e.decodeChannels={R:0};else if(i.Y)e.outputChannels=1,e.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(e.type===1)switch(r){case S.Float:e.getter=Z,e.inputSize=g;break;case S.HalfFloat:e.getter=z,e.inputSize=g;break}else if(e.type===2)switch(r){case S.Float:e.getter=H,e.inputSize=I;break;case S.HalfFloat:e.getter=Y,e.inputSize=I}else throw new Error("Unsupported pixelType "+e.type+" for "+n.compression);e.blockCount=e.height/e.scanlineBlockSize;for(let o=0;o<e.blockCount;o++)X(l,s);const a=e.width*e.height*e.outputChannels;switch(r){case S.Float:e.byteArray=new Float32Array(a),e.textureType=1,t&&e.byteArray.fill(1,0,a);break;case S.HalfFloat:e.byteArray=new Uint16Array(a),e.textureType=2,t&&e.byteArray.fill(15360,0,a);break;default:throw new Error("Unsupported type: "+r)}let c=0;for(const o of n.channels)e.decodeChannels[o.name]!==void 0&&(e.channelLineOffsets[o.name]=c*e.width),c+=o.pixelType*2;return e.bytesPerLine=e.width*c,e.outLineWidth=e.width*e.outputChannels,n.lineOrder==="INCREASING_Y"?e.scanOrder=o=>o:e.scanOrder=o=>e.height-1-o,e.outputChannels==4?(e.format=5,e.linearSpace=!0):(e.format=6,e.linearSpace=!1),e}function nn(n,l,s,r){const e={value:0};for(let i=0;i<n.height/n.scanlineBlockSize;i++){const t=j(s,r)-l.dataWindow.yMin;n.size=P(s,r),n.lines=t+n.scanlineBlockSize>n.height?n.height-t:n.scanlineBlockSize;const c=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):v(n);r.value+=n.size;for(let o=0;o<n.scanlineBlockSize;o++){const u=i*n.scanlineBlockSize,h=o+n.scanOrder(u);if(h>=n.height)continue;const w=o*n.bytesPerLine,C=(n.height-1-h)*n.outLineWidth;for(let f=0;f<n.channels;f++){const p=l.channels[f].name,y=n.channelLineOffsets[p],b=n.decodeChannels[p];if(b!==void 0){e.value=w+y;for(let A=0;A<n.width;A++){const D=C+A*n.outputChannels+b;n.byteArray&&(n.byteArray[D]=n.getter(c,e))}}}}}}class tn{constructor(){this.supportCascades=!1}loadCubeData(l,s,r,e,i){throw".exr not supported in Cube."}loadData(l,s,r){const e=new DataView(l.buffer),i={value:0},t=q(e,i);d(t,e,i,E.DefaultOutputType).then(a=>{nn(a,t,e,i);const c=t.dataWindow.xMax-t.dataWindow.xMin+1,o=t.dataWindow.yMax-t.dataWindow.yMin+1;r(c,o,s.generateMipMaps,!1,()=>{const u=s.getEngine();s.format=t.format,s.type=a.textureType,s.invertY=!1,s._gammaSpace=!t.linearSpace,a.byteArray&&u._uploadDataToTextureDirectly(s,a.byteArray,0,0,void 0,!0)})}).catch(a=>{k.Error("Failed to load EXR texture: ",a)})}}export{tn as _ExrTextureLoader};
